import re
import json
import base64
import tempfile
import urllib.request
from fastapi import FastAPI, HTTPException
from fastapi.responses import RedirectResponse
import yt_dlp


# YouTube cookies for authentication (base64 encoded)
COOKIES_BASE64 = "IyBOZXRzY2FwZSBIVFRQIENvb2tpZSBGaWxlCiMgaHR0cHM6Ly9jdXJsLmhheHguc2UvcmZjL2Nvb2tpZV9zcGVjLmh0bWwKIyBUaGlzIGlzIGEgZ2VuZXJhdGVkIGZpbGUhIERvIG5vdCBlZGl0LgoKLnlvdXR1YmUuY29tCVRSVUUJLwlUUlVFCTE3Njc4ODAxMTAJR1BTCTEKLnlvdXR1YmUuY29tCVRSVUUJLwlUUlVFCTE4MDI0Mzg0MDEJUFJFRglmND00MDAwMDAwJmY2PTQwMDAwMDAwJnR6PUFzaWEuQ2FsY3V0dGEKYWNjb3VudHMuZ29vZ2xlLmNvbQlGQUxTRQkvCVRSVUUJMTc3MDQ3MDMxNwlPVFoJODQyNjIzOV8zNF8zNF9fMzRfCi5nb29nbGUuY29tCVRSVUUJLwlUUlVFCTE3ODM2ODk1MTcJTklECTUyNz0wRlY2bTBVbTItMVNPMU0wRkEzZ1Vra0o2eDZnWE1acklDajdqc2ZmWV9TTGNOY1BqeUs5T3AzSUZJUXZTYk1hekRVWnZ1RUFuVUJyWERqMzlUVndEN1FJWmdkSzlvS3FzSkFUS0NOSmM3eHdwVDdpRVZudmhsenB6dFoxUVBrOXNheVJfZ0lEcGV6LWVudVpsODY3UlgzRTlQbUtiYlJMUGZVMVhPOFlsWlBSUlhZVjdSR3BocXQ0VHZHbGFMMW1ieTQ0UTh3a2lGNks1OE9lWVhPMlJoaTR1OGlCaW1wYzI4cF9TdGtGWkppWjVWS3IzUXdNN2c4RWh3N05JdlZhSThONktOWUJoejdQeTJzeFczTGpMc1REaW5FM2drc2hqU2JBMGRTYVVrVU1MQ2RUZzhKMkU0aExteVBKNEhxemhjaU9KZUZGLTBxMEplVW54RkxqVm5vb0V2RnJ4ZDJ2b2diMlJpT053U1puZ3ZvdXpkUUNWWncyVkNuN3lGVV82UzJXQnpnYldxc2lKdzExTEQyNjBudkZmaTVSdzZwSkw1YWlwVWxqWUROZEVkMzFMZXdtMUFoMmhrZ0VLVHFyT3ZKWjdsdGdJSkNlLWEzN0tmMTgwNkgtdjVMeFRUWHViTHpHWXMwaDN1U09wQi1DcFQxV0FieTZnM09DWG1ySmw3S2NiSzBtYjZtSHA1bTRoYmx3TlE5Q082RXNhNTdjSFloUUI2aWxNNTNMT1d1N3k2WXdlcWNyWmlUU205VDNwaS1PUDFPeU45bUtvSHlFdFhRMWJFdncwMXJ0OWhlNXNYMmRPVVRmU0lzay0teDVnTFZKLWNHVzBjb0p1YUFwU1pseXZPUXBLWExHUlpaUjc5bzhwZwouZ29vZ2xlLmNvbQlUUlVFCS8JRkFMU0UJMTgwMjQzODM5NwlTSUQJZy5hMDAwNVFqRTI5UnU1TGVnWTRuNlRueW9VVklxZnhXMTJPZ1ZwVjdtSDFKNEpBMFgyaTRKRHBtX0hPMG1Fckd1cXB0OUtITzByUUFDZ1lLQVNvU0FSUVNGUUhHWDJNaUZORzFSelRvclcwbFdHSDUtWmwtaGhvVkFVRjh5S293NC03ZnFleWZzYXV0bGlkcjIwRi0wMDc2Ci5nb29nbGUuY29tCVRSVUUJLwlUUlVFCTE4MDI0MzgzOTcJX19TZWN1cmUtMVBTSUQJZy5hMDAwNVFqRTI5UnU1TGVnWTRuNlRueW9VVklxZnhXMTJPZ1ZwVjdtSDFKNEpBMFgyaTRKYlRENDVlb0lDZjlwRWMxTTVoTXl1UUFDZ1lLQWQ0U0FSUVNGUUhHWDJNaU84UGZrX21wSzZIVVJtTGNVTjhCQmhvVkFVRjh5S3F0M1JsVURWSEJfejA5QzJJc3VqWGIwMDc2Ci5nb29nbGUuY29tCVRSVUUJLwlUUlVFCTE4MDI0MzgzOTcJX19TZWN1cmUtM1BTSUQJZy5hMDAwNVFqRTI5UnU1TGVnWTRuNlRueW9VVklxZnhXMTJPZ1ZwVjdtSDFKNEpBMFgyaTRKV0tXN2tlOEMwbDF2Wl9VYlVndmtuQUFDZ1lLQVowU0FSUVNGUUhHWDJNaXRoSlVWVk8xY1g1eVpHRjVRMm9VYUJvVkFVRjh5S29ralBHOXFoUHR1Rms4TzBteHNBc0EwMDc2Ci5nb29nbGUuY29tCVRSVUUJLwlGQUxTRQkxODAyNDM4Mzk3CUhTSUQJQXBGQ2dGREZlZFZhc3g4ZW8KLmdvb2dsZS5jb20JVFJVRQkvCVRSVUUJMTgwMjQzODM5NwlTU0lECUFWSi1ycUQxZ0pveG1OQWg5Ci5nb29nbGUuY29tCVRSVUUJLwlGQUxTRQkxODAyNDM4Mzk3CUFQSVNJRAloaERLVllCbkg1cndMeW5ML0F0bVdnc0MxcFhVbkRyQ3lsCi5nb29nbGUuY29tCVRSVUUJLwlUUlVFCTE4MDI0MzgzOTcJU0FQSVNJRAlRWXVBYWxDZVQxcDFEZS05L0FXZDNVOWMyREVJVW94UzhjCi5nb29nbGUuY29tCVRSVUUJLwlUUlVFCTE4MDI0MzgzOTcJX19TZWN1cmUtMVBBUElTSUQJUVl1QWFsQ2VUMXAxRGUtOS9BV2QzVTljMkRFSVVveFM4YwouZ29vZ2xlLmNvbQlUUlVFCS8JVFJVRQkxODAyNDM4Mzk3CV9fU2VjdXJlLTNQQVBJU0lECVFZdUFhbENlVDFwMURlLTkvQVdkM1U5YzJERUlVb3hTOGMKYWNjb3VudHMuZ29vZ2xlLmNvbQlGQUxTRQkvCVRSVUUJMTgwMjQzODM5NwlfX0hvc3QtR0FQUwkxOnI3WFI4T1BybGVNZV9ZMGdZd2lHV0xUTDV2dmt1UHBhZmlvV3Y4QUFfV1dydjd0U2UtSENBejg2UlpQdk1idjlPc2Jkb0RZTGZMci1MT3NkOTBRVHFjalh4M0EzeGc6dXBQLVc1UWNPelNhaGNETgphY2NvdW50cy5nb29nbGUuY29tCUZBTFNFCS8JVFJVRQkxODAyNDM4Mzk3CUxTSUQJcy5JTnxzLnlvdXR1YmU6Zy5hMDAwNVFqRTJfNGZnX21INS1yOFFTcDI0V2ktd3B2aVA0T0tBNHZZbG56RnRHV0FRZDhWQk5DdnpyLVlmN1dobnl1UlJFbXNiZ0FDZ1lLQWVNU0FSUVNGUUhHWDJNaVljTHV1WjJLUDRvVFV0TlZSYlRZS1JvVkFVRjh5S3FZWmpCdU51QXkyc0hHQ0U4WVdZTEQwMDc2CmFjY291bnRzLmdvb2dsZS5jb20JRkFMU0UJLwlUUlVFCTE4MDI0MzgzOTcJX19Ib3N0LTFQTFNJRAlzLklOfHMueW91dHViZTpnLmEwMDA1UWpFMl80ZmdfbUg1LXI4UVNwMjRXaS13cHZpUDRPS0E0dllsbnpGdEdXQVFkOFZzZi1oUnF6STVrV3dLYnBXYTVzZG1nQUNnWUtBZVFTQVJRU0ZRSEdYMk1pOFVaNW1HUVFNaC1yTmhoUlU3UVNzeG9WQVVGOHlLcTAxQmpKUkkxSXhlVWFoVlQ3aG9RRjAwNzYKYWNjb3VudHMuZ29vZ2xlLmNvbQlGQUxTRQkvCVRSVUUJMTgwMjQzODM5NwlfX0hvc3QtM1BMU0lECXMuSU58cy55b3V0dWJlOmcuYTAwMDVRakUyXzRmZ19tSDUtcjhRU3AyNFdpLXdwdmlQNE9LQTR2WWxuekZ0R1dBUWQ4VlZNQ2pyWGV3UlFnQU1LcTJFbl9fNFFBQ2dZS0FYc1NBUlFTRlFIR1gyTWlJb0Jpd213aUtXSjJWOHBqalQzRmZSb1ZBVUY4eUtyc2lrTWxFMFVCUnBCVm5kUFp3S19MMDA3NgphY2NvdW50cy5nb29nbGUuY29tCUZBTFNFCS8JVFJVRQkxODAyNDM4Mzk3CUFDQ09VTlRfQ0hPT1NFUglBRnhfcUk1ZGNPNXpMTnZHMXJCTmYxeEEwbUdIQmQwZ2twWjNZbGJtT3pMa3dNbnZxRFNydHlOLVZFXzBQTjcxN1FMWXdIcEozMmFYd2o4eFZCSjhlOWozWnMtTUFKZWU1MGtuenZGaFVJV25fa2ZobUdoMTRmWHJ0N0lIZzh0WWhuT3hQSVB4NEFSVgouZ29vZ2xlLmNvbQlUUlVFCS8JRkFMU0UJMTc5OTQxNDM5NwlTSURDQwlBS0V5WHpWWUQ4dDdDT25XVHJnd0R0eFRaVUphQk9xcHVZSzBCbHdEaTZ6Ny1mZHllekE1UmMwbWd1RXJaTFlOQndBOVNoU28KLmdvb2dsZS5jb20JVFJVRQkvCVRSVUUJMTc5OTQxNDM5NwlfX1NlY3VyZS0xUFNJRENDCUFLRXlYelZCRzJ6cV9Wb0hZbTkwMWhBeGZ5YlNOaFpxSnRUbWlzZEozS2txR0poTEFBanNiRjVkUGpIR01vT1UzRFhpQ0dSVmRRCi5nb29nbGUuY29tCVRSVUUJLwlUUlVFCTE3OTk0MTQzOTcJX19TZWN1cmUtM1BTSURDQwlBS0V5WHpXZEk5Wk5jSzg5Q3NoLTRUZWJ0cmRCNW9TdWZOc3ZmZUQxZDFYVllwRmFCcWdkRThGOTZGeTNTSTh0TWw3Nzl1aVBjQQoueW91dHViZS5jb20JVFJVRQkvCVRSVUUJMTc5OTQxNDM5OAlfX1NlY3VyZS0xUFNJRFRTCXNpZHRzLUNqUUJmbGFDZFNmRHJNUS1YZmdObWpDV21NWWpxdHFheHlFVlMyUG5ydF9VeWZWamprREpmelRkMVBsUV9mSF91aWZCaHVTWkVBQQoueW91dHViZS5jb20JVFJVRQkvCVRSVUUJMTc5OTQxNDM5OAlfX1NlY3VyZS0zUFNJRFRTCXNpZHRzLUNqUUJmbGFDZFNmRHJNUS1YZmdObWpDV21NWWpxdHFheHlFVlMyUG5ydF9VeWZWamprREpmelRkMVBsUV9mSF91aWZCaHVTWkVBQQoueW91dHViZS5jb20JVFJVRQkvCUZBTFNFCTE4MDI0MzgzOTgJSFNJRAlBUExBN2VFYmJ3Vll1dnp6egoueW91dHViZS5jb20JVFJVRQkvCVRSVUUJMTgwMjQzODM5OAlTU0lECUE1b1Nwa2czWlJDRmtsTFRpCi55b3V0dWJlLmNvbQlUUlVFCS8JRkFMU0UJMTgwMjQzODM5OAlBUElTSUQJaGhES1ZZQm5INXJ3THluTC9BdG1XZ3NDMXBYVW5EckN5bAoueW91dHViZS5jb20JVFJVRQkvCVRSVUUJMTgwMjQzODM5OAlTQVBJU0lECVFZdUFhbENlVDFwMURlLTkvQVdkM1U5YzJERUlVb3hTOGMKLnlvdXR1YmUuY29tCVRSVUUJLwlUUlVFCTE4MDI0MzgzOTgJX19TZWN1cmUtMVBBUElTSUQJUVl1QWFsQ2VUMXAxRGUtOS9BV2QzVTljMkRFSVVveFM4YwoueW91dHViZS5jb20JVFJVRQkvCVRSVUUJMTgwMjQzODM5OAlfX1NlY3VyZS0zUEFQSVNJRAlRWXVBYWxDZVQxcDFEZS05L0FXZDNVOWMyREVJVW94UzhjCi55b3V0dWJlLmNvbQlUUlVFCS8JRkFMU0UJMTgwMjQzODM5OAlTSUQJZy5hMDAwNVFqRTI5UnU1TGVnWTRuNlRueW9VVklxZnhXMTJPZ1ZwVjdtSDFKNEpBMFgyaTRKRHBtX0hPMG1Fckd1cXB0OUtITzByUUFDZ1lLQVNvU0FSUVNGUUhHWDJNaUZORzFSelRvclcwbFdHSDUtWmwtaGhvVkFVRjh5S293NC03ZnFleWZzYXV0bGlkcjIwRi0wMDc2Ci55b3V0dWJlLmNvbQlUUlVFCS8JVFJVRQkxODAyNDM4Mzk4CV9fU2VjdXJlLTFQU0lECWcuYTAwMDVRakUyOVJ1NUxlZ1k0bjZUbnlvVVZJcWZ4VzEyT2dWcFY3bUgxSjRKQTBYMmk0SmJURDQ1ZW9JQ2Y5cEVjMU01aE15dVFBQ2dZS0FkNFNBUlFTRlFIR1gyTWlPOFBma19tcEs2SFVSbUxjVU44QkJob1ZBVUY4eUtxdDNSbFVEVkhCX3owOUMySXN1alhiMDA3NgoueW91dHViZS5jb20JVFJVRQkvCVRSVUUJMTgwMjQzODM5OAlfX1NlY3VyZS0zUFNJRAlnLmEwMDA1UWpFMjlSdTVMZWdZNG42VG55b1VWSXFmeFcxMk9nVnBWN21IMUo0SkEwWDJpNEpXS1c3a2U4QzBsMXZaX1ViVWd2a25BQUNnWUtBWjBTQVJRU0ZRSEdYMk1pdGhKVVZWTzFjWDV5WkdGNVEyb1VhQm9WQVVGOHlLb2tqUEc5cWhQdHVGazhPMG14c0FzQTAwNzYKLmdvb2dsZS5jby5pbglUUlVFCS8JRkFMU0UJMTgwMjQzODM5OQlIU0lECUFQTEE3ZUViYndWWXV2enp6Ci5nb29nbGUuY28uaW4JVFJVRQkvCVRSVUUJMTgwMjQzODM5OQlTU0lECUE1b1Nwa2czWlJDRmtsTFRpCi5nb29nbGUuY28uaW4JVFJVRQkvCUZBTFNFCTE4MDI0MzgzOTkJQVBJU0lECWhoREtWWUJuSDVyd0x5bkwvQXRtV2dzQzFwWFVuRHJDeWwKLmdvb2dsZS5jby5pbglUUlVFCS8JVFJVRQkxODAyNDM4Mzk5CVNBUElTSUQJUVl1QWFsQ2VUMXAxRGUtOS9BV2QzVTljMkRFSVVveFM4YwouZ29vZ2xlLmNvLmluCVRSVUUJLwlUUlVFCTE4MDI0MzgzOTkJX19TZWN1cmUtMVBBUElTSUQJUVl1QWFsQ2VUMXAxRGUtOS9BV2QzVTljMkRFSVVveFM4YwouZ29vZ2xlLmNvLmluCVRSVUUJLwlUUlVFCTE4MDI0MzgzOTkJX19TZWN1cmUtM1BBUElTSUQJUVl1QWFsQ2VUMXAxRGUtOS9BV2QzVTljMkRFSVVveFM4YwouZ29vZ2xlLmNvLmluCVRSVUUJLwlUUlVFCTE3ODM2ODk1OTkJTklECTUyNz1iOFU5V3dvZzJmRnk2QVlGMXdzaFpDVTBKZjh5YlpFVkw0bl80ZTBVUWplcHdCUlZKMUFZSGgxYk5WMFZHYjFxeFNNNlBrQVNna0ItejFQSUlpOHY0dm5ZY0IzaHdOYmZwRVpkNzNkRGF0djNDc0N4U1F5OXQtQW1ydFJnd2VXM2d4Q2hURkFvQ0FqQWtYMnNxSVdkS20tajR4OVZiN2cwSGlEejhHZTgxLWxmRWFMVnV3ZmRQR3ZiT3pzOWozR3FuWDJjZW1JMDdVZzlwTU5kbnpYQWNkVnFkamMKLmdvb2dsZS5jby5pbglUUlVFCS8JRkFMU0UJMTgwMjQzODM5OQlTSUQJZy5hMDAwNVFqRTI5UnU1TGVnWTRuNlRueW9VVklxZnhXMTJPZ1ZwVjdtSDFKNEpBMFgyaTRKRHBtX0hPMG1Fckd1cXB0OUtITzByUUFDZ1lLQVNvU0FSUVNGUUhHWDJNaUZORzFSelRvclcwbFdHSDUtWmwtaGhvVkFVRjh5S293NC03ZnFleWZzYXV0bGlkcjIwRi0wMDc2Ci5nb29nbGUuY28uaW4JVFJVRQkvCVRSVUUJMTgwMjQzODM5OQlfX1NlY3VyZS0xUFNJRAlnLmEwMDA1UWpFMjlSdTVMZWdZNG42VG55b1VWSXFmeFcxMk9nVnBWN21IMUo0SkEwWDJpNEpiVEQ0NWVvSUNmOXBFYzFNNWhNeXVRQUNnWUtBZDRTQVJRU0ZRSEdYMk1pTzhQZmtfbXBLNkhVUm1MY1VOOEJCaG9WQVVGOHlLcXQzUmxVRFZIQl96MDlDMklzdWpYYjAwNzYKLmdvb2dsZS5jby5pbglUUlVFCS8JVFJVRQkxODAyNDM4Mzk5CV9fU2VjdXJlLTNQU0lECWcuYTAwMDVRakUyOVJ1NUxlZ1k0bjZUbnlvVVZJcWZ4VzEyT2dWcFY3bUgxSjRKQTBYMmk0SldLVzdrZThDMGwxdlpfVWJVZ3ZrbkFBQ2dZS0FaMFNBUlFTRlFIR1gyTWl0aEpVVlZPMWNYNXlaR0Y1UTJvVWFCb1ZBVUY4eUtva2pQRzlxaFB0dUZrOE8wbXhzQXNBMDA3NgoueW91dHViZS5jb20JVFJVRQkvCVRSVUUJMTgwMjQzODM5OQlMT0dJTl9JTkZPCUFGbW1GMnN3UmdJaEFPR3dfemdBbktDcHdVTTVvU3BfeVhyamY0OEJ0RVFUWWw1QUEtWEpRMTJvQWlFQWxSMVpBZ1JxaENCNGVQaktLbzB3QWNsN3p2M29KQmFMTW1ocW4tYmwyRnc6UVVRM01qTm1lRUo2VlhkVWJFMXpka1J3TWpsbGRuSkpMV04xYVhaMFMyYzBVM0JhWVRkaWRqaERTVGM0UjBsSmQxOWlZMnRsYUZsTU9YQXRXVFI2TkVWVlJuRnNNM1JNYzFCRk1FOXFVbWxzTUhSM1VGWTNUblp3UVU1UExYRm5MVXQzYkZOeE0yaDVkVUpVU1cxV1ZIWktVVTB3TTJWSU1FOVZXSGxKYzFGNk5YWjZWblpJTVRNMVRVMHljVUpCYmpOMk1FUkNjWFZ4U0UxelRGcFdSRUpuCi55b3V0dWJlLmNvbQlUUlVFCS8JRkFMU0UJMTc5OTQxNDQwNAlTSURDQwlBS0V5WHpYTjV0NFQ3T3NaeGpWeVVmV0FNOE9jb3NzRVJ3cGFGblVOX2dPa21GT2ZETGdkaFVMSk1NRjNzX3dpNWtvUVNkRVkKLnlvdXR1YmUuY29tCVRSVUUJLwlUUlVFCTE3OTk0MTQ0MDQJX19TZWN1cmUtMVBTSURDQwlBS0V5WHpWcWdObGFkb2RERk5nSHk2cUpXY2stT0gyREhVdElVOWpaQjg1MmljN1diWU91bUdFeWN1S3dXUXFPVjB2em5sSjhRUQoueW91dHViZS5jb20JVFJVRQkvCVRSVUUJMTc5OTQxNDQwNAlfX1NlY3VyZS0zUFNJRENDCUFLRXlYeldlOTJHUV9rd3BkakFrWGhnd2tvOTFGMnoxM2FfeGp0ay1ldzJtUHdCN0psVDJESHhES2JnaGJienJXVTZlYTM3awoueW91dHViZS5jb20JVFJVRQkvCVRSVUUJMTc2Nzg4MDExMAlHUFMJMQoueW91dHViZS5jb20JVFJVRQkvCVRSVUUJMAlZU0MJV1I5UWlOc09HLTAKLnlvdXR1YmUuY29tCVRSVUUJLwlUUlVFCTE3ODM0MzA0MDQJVklTSVRPUl9JTkZPMV9MSVZFCXE4M092TW0ycDVVCi55b3V0dWJlLmNvbQlUUlVFCS8JVFJVRQkxNzgzNDMwNDA0CVZJU0lUT1JfUFJJVkFDWV9NRVRBREFUQQlDZ0pKVGhJRUdnQWdUUSUzRCUzRAoueW91dHViZS5jb20JVFJVRQkvCVRSVUUJMTgwMjQzODQwMQlQUkVGCWY0PTQwMDAwMDAmZjY9NDAwMDAwMDAmdHo9QXNpYS5DYWxjdXR0YQoueW91dHViZS5jb20JVFJVRQkvCVRSVUUJMTc4MzQzMDMxMwlfX1NlY3VyZS1ST0xMT1VUX1RPS0VOCUNJR2RfYV9EdU5tYXRnRVExS2pBOVlQOGtRTVl1NWJIOW9QOGtRTSUzRAphY2NvdW50cy5nb29nbGUuY29tCUZBTFNFCS8JVFJVRQkxNzcwNDcwMzE3CU9UWgk4NDI2MjM5XzM0XzM0X18zNF8KLmdvb2dsZS5jb20JVFJVRQkvCVRSVUUJMTc4MzY4OTUxNwlOSUQJNTI3PTBGVjZtMFVtMi0xU08xTTBGQTNnVWtrSjZ4NmdYTVpySUNqN2pzZmZZX1NMY05jUGp5SzlPcDNJRklRdlNiTWF6RFVadnVFQW5VQnJYRGozOVRWd0Q3UUlaZ2RLOW9LcXNKQVRLQ05KYzd4d3BUN2lFVm52aGx6cHp0WjFRUGs5c2F5Ul9nSURwZXotZW51Wmw4NjdSWDNFOVBtS2JiUkxQZlUxWE84WWxaUFJSWFlWN1JHcGhxdDRUdkdsYUwxbWJ5NDRROHdraUY2SzU4T2VZWE8yUmhpNHU4aUJpbXBjMjhwX1N0a0ZaSmlaNVZLcjNRd003ZzhFaHc3Tkl2VmFJOE42S05ZQmh6N1B5MnN4VzNMakxzVERpbkUzZ2tzaGpTYkEwZFNhVWtVTUxDZFRnOEoyRTRoTG15UEo0SHF6aGNpT0plRkYtMHEwSmVVbnhGTGpWbm9vRXZGcnhkMnZvZ2IyUmlPTndTWm5ndm91emRRQ1ZadzJWQ243eUZVXzZTMldCemdiV3FzaUp3MTFMRDI2MG52RmZpNVJ3NnBKTDVhaXBVbGpZRE5kRWQzMUxld20xQWgyaGtnRUtUcXJPdkpaN2x0Z0lKQ2UtYTM3S2YxODA2SC12NUx4VFRYdWJMekdZczBoM3VTT3BCLUNwVDFXQWJ5NmczT0NYbXJKbDdLY2JLMG1iNm1IcDVtNGhibHdOUTlDTzZFc2E1N2NIWWhRQjZpbE01M0xPV3U3eTZZd2VxY3JaaVRTbTlUM3BpLU9QMU95TjltS29IeUV0WFExYkV2dzAxcnQ5aGU1c1gyZE9VVGZTSXNrLS14NWdMVkotY0dXMGNvSnVhQXBTWmx5dk9RcEtYTEdSWlpSNzlvOHBnCi5nb29nbGUuY29tCVRSVUUJLwlGQUxTRQkxODAyNDM4Mzk3CVNJRAlnLmEwMDA1UWpFMjlSdTVMZWdZNG42VG55b1VWSXFmeFcxMk9nVnBWN21IMUo0SkEwWDJpNEpEcG1fSE8wbUVyR3VxcHQ5S0hPMHJRQUNnWUtBU29TQVJRU0ZRSEdYMk1pRk5HMVJ6VG9yVzBsV0dINS1abC1oaG9WQVVGOHlLb3c0LTdmcWV5ZnNhdXRsaWRyMjBGLTAwNzYKLmdvb2dsZS5jb20JVFJVRQkvCVRSVUUJMTgwMjQzODM5NwlfX1NlY3VyZS0xUFNJRAlnLmEwMDA1UWpFMjlSdTVMZWdZNG42VG55b1VWSXFmeFcxMk9nVnBWN21IMUo0SkEwWDJpNEpiVEQ0NWVvSUNmOXBFYzFNNWhNeXVRQUNnWUtBZDRTQVJRU0ZRSEdYMk1pTzhQZmtfbXBLNkhVUm1MY1VOOEJCaG9WQVVGOHlLcXQzUmxVRFZIQl96MDlDMklzdWpYYjAwNzYKLmdvb2dsZS5jb20JVFJVRQkvCVRSVUUJMTgwMjQzODM5NwlfX1NlY3VyZS0zUFNJRAlnLmEwMDA1UWpFMjlSdTVMZWdZNG42VG55b1VWSXFmeFcxMk9nVnBWN21IMUo0SkEwWDJpNEpXS1c3a2U4QzBsMXZaX1ViVWd2a25BQUNnWUtBWjBTQVJRU0ZRSEdYMk1pdGhKVVZWTzFjWDV5WkdGNVEyb1VhQm9WQVVGOHlLb2tqUEc5cWhQdHVGazhPMG14c0FzQTAwNzYKLmdvb2dsZS5jb20JVFJVRQkvCUZBTFNFCTE4MDI0MzgzOTcJSFNJRAlBcEZDZ0ZERmVkVmFzeDhlbwouZ29vZ2xlLmNvbQlUUlVFCS8JVFJVRQkxODAyNDM4Mzk3CVNTSUQJQVZKLXJxRDFnSm94bU5BaDkKLmdvb2dsZS5jb20JVFJVRQkvCUZBTFNFCTE4MDI0MzgzOTcJQVBJU0lECWhoREtWWUJuSDVyd0x5bkwvQXRtV2dzQzFwWFVuRHJDeWwKLmdvb2dsZS5jb20JVFJVRQkvCVRSVUUJMTgwMjQzODM5NwlTQVBJU0lECVFZdUFhbENlVDFwMURlLTkvQVdkM1U5YzJERUlVb3hTOGMKLmdvb2dsZS5jb20JVFJVRQkvCVRSVUUJMTgwMjQzODM5NwlfX1NlY3VyZS0xUEFQSVNJRAlRWXVBYWxDZVQxcDFEZS05L0FXZDNVOWMyREVJVW94UzhjCi5nb29nbGUuY29tCVRSVUUJLwlUUlVFCTE4MDI0MzgzOTcJX19TZWN1cmUtM1BBUElTSUQJUVl1QWFsQ2VUMXAxRGUtOS9BV2QzVTljMkRFSVVveFM4YwphY2NvdW50cy5nb29nbGUuY29tCUZBTFNFCS8JVFJVRQkxODAyNDM4Mzk3CV9fSG9zdC1HQVBTCTE6cjdYUjhPUHJsZU1lX1kwZ1l3aUdXTFRMNXZ2a3VQcGFmaW9XdjhBQV9XV3J2N3RTZS1IQ0F6ODZSWlB2TWJ2OU9zYmRvRFlMZkxyLUxPc2Q5MFFUcWNqWHgzQTN4Zzp1cFAtVzVRY096U2FoY0ROCmFjY291bnRzLmdvb2dsZS5jb20JRkFMU0UJLwlUUlVFCTE4MDI0MzgzOTcJTFNJRAlzLklOfHMueW91dHViZTpnLmEwMDA1UWpFMl80ZmdfbUg1LXI4UVNwMjRXaS13cHZpUDRPS0E0dllsbnpGdEdXQVFkOFZCTkN2enItWWY3V2hueXVSUkVtc2JnQUNnWUtBZU1TQVJRU0ZRSEdYMk1pWWNMdXVaMktQNG9UVXROVlJiVFlLUm9WQVVGOHlLcVlaakJ1TnVBeTJzSEdDRThZV1lMRDAwNzYKYWNjb3VudHMuZ29vZ2xlLmNvbQlGQUxTRQkvCVRSVUUJMTgwMjQzODM5NwlfX0hvc3QtMVBMU0lECXMuSU58cy55b3V0dWJlOmcuYTAwMDVRakUyXzRmZ19tSDUtcjhRU3AyNFdpLXdwdmlQNE9LQTR2WWxuekZ0R1dBUWQ4VnNmLWhScXpJNWtXd0ticFdhNXNkbWdBQ2dZS0FlUVNBUlFTRlFIR1gyTWk4VVo1bUdRUU1oLXJOaGhSVTdRU3N4b1ZBVUY4eUtxMDFCakpSSTFJeGVVYWhWVDdob1FGMDA3NgphY2NvdW50cy5nb29nbGUuY29tCUZBTFNFCS8JVFJVRQkxODAyNDM4Mzk3CV9fSG9zdC0zUExTSUQJcy5JTnxzLnlvdXR1YmU6Zy5hMDAwNVFqRTJfNGZnX21INS1yOFFTcDI0V2ktd3B2aVA0T0tBNHZZbG56RnRHV0FRZDhWVk1DanJYZXdSUWdBTUtxMkVuX180UUFDZ1lLQVhzU0FSUVNGUUhHWDJNaUlvQml3bXdpS1dKMlY4cGpqVDNGZlJvVkFVRjh5S3JzaWtNbEUwVUJScEJWbmRQWndLX0wwMDc2CmFjY291bnRzLmdvb2dsZS5jb20JRkFMU0UJLwlUUlVFCTE4MDI0MzgzOTcJQUNDT1VOVF9DSE9PU0VSCUFGeF9xSTVkY081ekxOdkcxckJOZjF4QTBtR0hCZDBna3BaM1lsYm1Pekxrd01udnFEU3J0eU4tVkVfMFBONzE3UUxZd0hwSjMyYVh3ajh4VkJKOGU5ajNacy1NQUplZTUwa256dkZoVUlXbl9rZmhtR2gxNGZYcnQ3SUhnOHRZaG5PeFBJUHg0QVJWCi5nb29nbGUuY29tCVRSVUUJLwlGQUxTRQkxNzk5NDE0Mzk3CVNJRENDCUFLRXlYelZZRDh0N0NPbldUcmd3RHR4VFpVSmFCT3FwdVlLMEJsd0RpNno3LWZkeWV6QTVSYzBtZ3VFclpMWU5Cd0E5U2hTbwouZ29vZ2xlLmNvbQlUUlVFCS8JVFJVRQkxNzk5NDE0Mzk3CV9fU2VjdXJlLTFQU0lEQ0MJQUtFeVh6VkJHMnpxX1ZvSFltOTAxaEF4ZnliU05oWnFKdFRtaXNkSjNLa3FHSmhMQUFqc2JGNWRQakhHTW9PVTNEWGlDR1JWZFEKLmdvb2dsZS5jb20JVFJVRQkvCVRSVUUJMTc5OTQxNDM5NwlfX1NlY3VyZS0zUFNJRENDCUFLRXlYeldkSTlaTmNLODlDc2gtNFRlYnRyZEI1b1N1Zk5zdmZlRDFkMVhWWXBGYUJxZ2RFOEY5NkZ5M1NJOHRNbDc3OXVpUGNBCi55b3V0dWJlLmNvbQlUUlVFCS8JVFJVRQkxNzk5NDE0Mzk4CV9fU2VjdXJlLTFQU0lEVFMJc2lkdHMtQ2pRQmZsYUNkU2ZEck1RLVhmZ05takNXbU1ZanF0cWF4eUVWUzJQbnJ0X1V5ZlZqamtESmZ6VGQxUGxRX2ZIX3VpZkJodVNaRUFBCi55b3V0dWJlLmNvbQlUUlVFCS8JVFJVRQkxNzk5NDE0Mzk4CV9fU2VjdXJlLTNQU0lEVFMJc2lkdHMtQ2pRQmZsYUNkU2ZEck1RLVhmZ05takNXbU1ZanF0cWF4eUVWUzJQbnJ0X1V5ZlZqamtESmZ6VGQxUGxRX2ZIX3VpZkJodVNaRUFBCi55b3V0dWJlLmNvbQlUUlVFCS8JRkFMU0UJMTgwMjQzODM5OAlIU0lECUFQTEE3ZUViYndWWXV2enp6Ci55b3V0dWJlLmNvbQlUUlVFCS8JVFJVRQkxODAyNDM4Mzk4CVNTSUQJQTVvU3BrZzNaUkNGa2xMVGkKLnlvdXR1YmUuY29tCVRSVUUJLwlGQUxTRQkxODAyNDM4Mzk4CUFQSVNJRAloaERLVllCbkg1cndMeW5ML0F0bVdnc0MxcFhVbkRyQ3lsCi55b3V0dWJlLmNvbQlUUlVFCS8JVFJVRQkxODAyNDM4Mzk4CVNBUElTSUQJUVl1QWFsQ2VUMXAxRGUtOS9BV2QzVTljMkRFSVVveFM4YwoueW91dHViZS5jb20JVFJVRQkvCVRSVUUJMTgwMjQzODM5OAlfX1NlY3VyZS0xUEFQSVNJRAlRWXVBYWxDZVQxcDFEZS05L0FXZDNVOWMyREVJVW94UzhjCi55b3V0dWJlLmNvbQlUUlVFCS8JVFJVRQkxODAyNDM4Mzk4CV9fU2VjdXJlLTNQQVBJU0lECVFZdUFhbENlVDFwMURlLTkvQVdkM1U5YzJERUlVb3hTOGMKLnlvdXR1YmUuY29tCVRSVUUJLwlGQUxTRQkxODAyNDM4Mzk4CVNJRAlnLmEwMDA1UWpFMjlSdTVMZWdZNG42VG55b1VWSXFmeFcxMk9nVnBWN21IMUo0SkEwWDJpNEpEcG1fSE8wbUVyR3VxcHQ5S0hPMHJRQUNnWUtBU29TQVJRU0ZRSEdYMk1pRk5HMVJ6VG9yVzBsV0dINS1abC1oaG9WQVVGOHlLb3c0LTdmcWV5ZnNhdXRsaWRyMjBGLTAwNzYKLnlvdXR1YmUuY29tCVRSVUUJLwlUUlVFCTE4MDI0MzgzOTgJX19TZWN1cmUtMVBTSUQJZy5hMDAwNVFqRTI5UnU1TGVnWTRuNlRueW9VVklxZnhXMTJPZ1ZwVjdtSDFKNEpBMFgyaTRKYlRENDVlb0lDZjlwRWMxTTVoTXl1UUFDZ1lLQWQ0U0FSUVNGUUhHWDJNaU84UGZrX21wSzZIVVJtTGNVTjhCQmhvVkFVRjh5S3F0M1JsVURWSEJfejA5QzJJc3VqWGIwMDc2Ci55b3V0dWJlLmNvbQlUUlVFCS8JVFJVRQkxODAyNDM4Mzk4CV9fU2VjdXJlLTNQU0lECWcuYTAwMDVRakUyOVJ1NUxlZ1k0bjZUbnlvVVZJcWZ4VzEyT2dWcFY3bUgxSjRKQTBYMmk0SldLVzdrZThDMGwxdlpfVWJVZ3ZrbkFBQ2dZS0FaMFNBUlFTRlFIR1gyTWl0aEpVVlZPMWNYNXlaR0Y1UTJvVWFCb1ZBVUY4eUtva2pQRzlxaFB0dUZrOE8wbXhzQXNBMDA3NgouZ29vZ2xlLmNvLmluCVRSVUUJLwlGQUxTRQkxODAyNDM4Mzk5CUhTSUQJQVBMQTdlRWJid1ZZdXZ6enoKLmdvb2dsZS5jby5pbglUUlVFCS8JVFJVRQkxODAyNDM4Mzk5CVNTSUQJQTVvU3BrZzNaUkNGa2xMVGkKLmdvb2dsZS5jby5pbglUUlVFCS8JRkFMU0UJMTgwMjQzODM5OQlBUElTSUQJaGhES1ZZQm5INXJ3THluTC9BdG1XZ3NDMXBYVW5EckN5bAouZ29vZ2xlLmNvLmluCVRSVUUJLwlUUlVFCTE4MDI0MzgzOTkJU0FQSVNJRAlRWXVBYWxDZVQxcDFEZS05L0FXZDNVOWMyREVJVW94UzhjCi5nb29nbGUuY28uaW4JVFJVRQkvCVRSVUUJMTgwMjQzODM5OQlfX1NlY3VyZS0xUEFQSVNJRAlRWXVBYWxDZVQxcDFEZS05L0FXZDNVOWMyREVJVW94UzhjCi5nb29nbGUuY28uaW4JVFJVRQkvCVRSVUUJMTgwMjQzODM5OQlfX1NlY3VyZS0zUEFQSVNJRAlRWXVBYWxDZVQxcDFEZS05L0FXZDNVOWMyREVJVW94UzhjCi5nb29nbGUuY28uaW4JVFJVRQkvCVRSVUUJMTc4MzY4OTU5OQlOSUQJNTI3PWI4VTlXd29nMmZGeTZBWUYxd3NoWkNVMEpmOHliWkVWTDRuXzRlMFVRamVwd0JSVkoxQVlIaDFiTlYwVkdiMXF4U002UGtBU2drQi16MVBJSWk4djR2blljQjNod05iZnBFWmQ3M2REYXR2M0NzQ3hTUXk5dC1BbXJ0Umd3ZVczZ3hDaFRGQW9DQWpBa1gyc3FJV2RLbS1qNHg5VmI3ZzBIaUR6OEdlODEtbGZFYUxWdXdmZFBHdmJPenM5ajNHcW5YMmNlbUkwN1VnOXBNTmRuelhBY2RWcWRqYwouZ29vZ2xlLmNvLmluCVRSVUUJLwlGQUxTRQkxODAyNDM4Mzk5CVNJRAlnLmEwMDA1UWpFMjlSdTVMZWdZNG42VG55b1VWSXFmeFcxMk9nVnBWN21IMUo0SkEwWDJpNEpEcG1fSE8wbUVyR3VxcHQ5S0hPMHJRQUNnWUtBU29TQVJRU0ZRSEdYMk1pRk5HMVJ6VG9yVzBsV0dINS1abC1oaG9WQVVGOHlLb3c0LTdmcWV5ZnNhdXRsaWRyMjBGLTAwNzYKLmdvb2dsZS5jby5pbglUUlVFCS8JVFJVRQkxODAyNDM4Mzk5CV9fU2VjdXJlLTFQU0lECWcuYTAwMDVRakUyOVJ1NUxlZ1k0bjZUbnlvVVZJcWZ4VzEyT2dWcFY3bUgxSjRKQTBYMmk0SmJURDQ1ZW9JQ2Y5cEVjMU01aE15dVFBQ2dZS0FkNFNBUlFTRlFIR1gyTWlPOFBma19tcEs2SFVSbUxjVU44QkJob1ZBVUY4eUtxdDNSbFVEVkhCX3owOUMySXN1alhiMDA3NgouZ29vZ2xlLmNvLmluCVRSVUUJLwlUUlVFCTE4MDI0MzgzOTkJX19TZWN1cmUtM1BTSUQJZy5hMDAwNVFqRTI5UnU1TGVnWTRuNlRueW9VVklxZnhXMTJPZ1ZwVjdtSDFKNEpBMFgyaTRKV0tXN2tlOEMwbDF2Wl9VYlVndmtuQUFDZ1lLQVowU0FSUVNGUUhHWDJNaXRoSlVWVk8xY1g1eVpHRjVRMm9VYUJvVkFVRjh5S29ralBHOXFoUHR1Rms4TzBteHNBc0EwMDc2Ci55b3V0dWJlLmNvbQlUUlVFCS8JVFJVRQkxODAyNDM4Mzk5CUxPR0lOX0lORk8JQUZtbUYyc3dSZ0loQU9Hd196Z0FuS0Nwd1VNNW9TcF95WHJqZjQ4QnRFUVRZbDVBQS1YSlExMm9BaUVBbFIxWkFnUnFoQ0I0ZVBqS0tvMHdBY2w3enYzb0pCYUxNbWhxbi1ibDJGdzpRVVEzTWpObWVFSjZWWGRVYkUxemRrUndNamxsZG5KSkxXTjFhWFowUzJjMFUzQmFZVGRpZGpoRFNUYzRSMGxKZDE5aVkydGxhRmxNT1hBdFdUUjZORVZWUm5Gc00zUk1jMUJGTUU5cVVtbHNNSFIzVUZZM1RuWndRVTVQTFhGbkxVdDNiRk54TTJoNWRVSlVTVzFXVkhaS1VVMHdNMlZJTUU5VldIbEpjMUY2TlhaNlZuWklNVE0xVFUweWNVSkJiak4yTUVSQ2NYVnhTRTF6VEZwV1JFSm4KLnlvdXR1YmUuY29tCVRSVUUJLwlGQUxTRQkxNzk5NDE0NDA0CVNJRENDCUFLRXlYelhONXQ0VDdPc1p4alZ5VWZXQU04T2Nvc3NFUndwYUZuVU5fZ09rbUZPZkRMZ2RoVUxKTU1GM3Nfd2k1a29RU2RFWQoueW91dHViZS5jb20JVFJVRQkvCVRSVUUJMTc5OTQxNDQwNAlfX1NlY3VyZS0xUFNJRENDCUFLRXlYelZxZ05sYWRvZERGTmdIeTZxSldjay1PSDJESFV0SVU5alpCODUyaWM3V2JZT3VtR0V5Y3VLd1dRcU9WMHZ6bmxKOFFRCi55b3V0dWJlLmNvbQlUUlVFCS8JVFJVRQkxNzk5NDE0NDA0CV9fU2VjdXJlLTNQU0lEQ0MJQUtFeVh6V2U5MkdRX2t3cGRqQWtYaGd3a285MUYyejEzYV94anRrLWV3Mm1Qd0I3SmxUMkRIeERLYmdoYmJ6cldVNmVhMzdrCg=="

def get_cookies_file():
    """Create a temporary cookies file from base64 encoded content and return its path."""
    cookies_content = base64.b64decode(COOKIES_BASE64).decode('utf-8')
    tmp = tempfile.NamedTemporaryFile(mode='w', suffix='.txt', delete=False)
    tmp.write(cookies_content)
    tmp.close()
    return tmp.name


app = FastAPI(
    title="YouTube Transcript API",
    description="API to fetch YouTube video transcripts",
    version="1.0.0",
)


def extract_video_id(url_or_id: str) -> str:
    """Extract YouTube video ID from URL or return as-is if already an ID."""
    patterns = [
        r'(?:youtube\.com\/watch\?v=|youtu\.be\/|youtube\.com\/embed\/)([a-zA-Z0-9_-]{11})',
        r'^([a-zA-Z0-9_-]{11})$'
    ]
    for pattern in patterns:
        match = re.search(pattern, url_or_id)
        if match:
            return match.group(1)
    raise ValueError("Invalid YouTube URL or video ID")


def get_subtitles_with_ytdlp(video_id: str, lang: str = "en"):
    """Fetch subtitles using yt-dlp."""
    url = f"https://www.youtube.com/watch?v={video_id}"
    cookies_file = get_cookies_file()

    ydl_opts = {
        'skip_download': True,
        'writesubtitles': True,
        'writeautomaticsub': True,
        'subtitleslangs': [lang, 'en'],
        'subtitlesformat': 'json3',
        'quiet': True,
        'no_warnings': True,
        'cookiefile': cookies_file,
    }

    try:
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(url, download=False)
            subtitles = info.get('subtitles', {})
            automatic_captions = info.get('automatic_captions', {})

            for lang_code in [lang, 'en']:
                if lang_code in subtitles:
                    for fmt in subtitles[lang_code]:
                        if fmt.get('ext') == 'json3':
                            return fmt.get('url'), lang_code, False, None
                if lang_code in automatic_captions:
                    for fmt in automatic_captions[lang_code]:
                        if fmt.get('ext') == 'json3':
                            return fmt.get('url'), lang_code, True, None

            return None, None, None, None
    except Exception as e:
        return None, None, None, f"Error: {str(e)} | Cookie file: {cookies_file}"


def parse_json3_subtitles(subtitle_url: str):
    """Fetch and parse json3 subtitle format."""
    with urllib.request.urlopen(subtitle_url) as response:
        data = json.loads(response.read().decode())

    transcript = []
    for event in data.get('events', []):
        if 'segs' in event:
            text = ''.join(seg.get('utf8', '') for seg in event['segs']).strip()
            if text:
                transcript.append({
                    'text': text,
                    'start': event.get('tStartMs', 0) / 1000,
                    'duration': event.get('dDurationMs', 0) / 1000
                })

    return transcript


@app.get("/")
def root():
    """Redirect to API docs."""
    return RedirectResponse(url="/docs")


@app.get("/api/transcript/{video_id:path}")
def get_transcript(video_id: str, lang: str = "en"):
    """
    Fetch transcript for a YouTube video.

    - **video_id**: YouTube video ID or full URL
    - **lang**: Language code for transcript (default: en)
    """
    try:
        extracted_id = extract_video_id(video_id)
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))

    try:
        subtitle_url, actual_lang, is_auto, error_msg = get_subtitles_with_ytdlp(extracted_id, lang)

        if error_msg:
            raise HTTPException(status_code=500, detail=error_msg)

        if not subtitle_url:
            raise HTTPException(status_code=404, detail="No transcript available for this video")

        transcript_data = parse_json3_subtitles(subtitle_url)
        full_text = " ".join([entry['text'] for entry in transcript_data])

        return {
            "video_id": extracted_id,
            "language": actual_lang,
            "is_auto_generated": is_auto,
            "transcript": transcript_data,
            "full_text": full_text
        }
    except HTTPException:
        raise
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))


@app.get("/api/transcript-languages/{video_id:path}")
def get_available_languages(video_id: str):
    """
    Get available transcript languages for a YouTube video.

    - **video_id**: YouTube video ID or full URL
    """
    try:
        extracted_id = extract_video_id(video_id)
    except ValueError as e:
        raise HTTPException(status_code=400, detail=str(e))

    try:
        url = f"https://www.youtube.com/watch?v={extracted_id}"
        cookies_file = get_cookies_file()

        ydl_opts = {
            'skip_download': True,
            'quiet': True,
            'no_warnings': True,
            'cookiefile': cookies_file,
        }

        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            info = ydl.extract_info(url, download=False)
            subtitles = info.get('subtitles', {})
            automatic_captions = info.get('automatic_captions', {})

            languages = []
            for lang_code in subtitles:
                languages.append({"language_code": lang_code, "is_generated": False})
            for lang_code in automatic_captions:
                if lang_code not in subtitles:
                    languages.append({"language_code": lang_code, "is_generated": True})

            return {"video_id": extracted_id, "languages": languages}
    except Exception as e:
        raise HTTPException(status_code=500, detail=str(e))
